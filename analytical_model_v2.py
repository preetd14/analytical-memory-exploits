import random
import itertools
from typing import Dict, List, Tuple
import matplotlib.pyplot as plt

class GameSimulation:
     def __init__(self, config: Dict[str, float]):
          """Initialize the GameSimulation object with configuration parameters."""
          self.config = config
          self.budget_A = config.get("budget_A", 0) # Attacker's budget
          self.budget_D = config.get("budget_D", 0) # Defender's budget
          self.total_cost_D = 0
          self.combination_success_rates = {}  # Dictionary to store success rates for combinations
          self.defense_strategy = config.get("defense_strategy", "none")  # Default to 'none' if not specified
          self.mtd_num_vulnerabilities = 0

     def initialize_vulnerabilities(self) -> Dict[str, Dict[str, float]]:
          """Initialize vulnerability likelihoods and lists for each type."""
          vulnerability_lists = {}

          for vulnerability_type in self.config["vulnerability_types"]:
               num_vulnerabilities = random.randint(self.config["num_vuln"], (self.config["num_vuln"])*2)
               # Create a dictionary of vulnerabilities for each type with random probabilities
               vulnerabilities = {f"{vulnerability_type}_vuln_{i+1}": random.uniform(0.1, 0.9) for i in range(num_vulnerabilities)}
               if self.defense_strategy == "MTD" and vulnerability_type == "Pointer":
                    self.mtd_num_vulnerabilities += num_vulnerabilities


               if self.defense_strategy == "PRIME_redirect" and vulnerability_type in self.config.get("honey_viable_types", []): # and self.budget_D >0
                    # Add honey vulnerabilities for redirect defense strategy
                    K = int(self.config["honey_fraction"] * num_vulnerabilities)
                    # print(f"\nNumber of honey vulnerabilities to pad is {K}")
                    honey_vulnerabilities = {f"{vulnerability_type}_honey_vuln_{j+1}": random.uniform(0.8, 0.9) for j in range(K)}
                    vulnerabilities.update(honey_vulnerabilities)

                    # Lower the probabilities of real vulnerabilities and increase honey vulnerabilities' probabilities
                    for v in vulnerabilities:
                         if "honey" in v:
                              vulnerabilities[v] *= self.config["skew_honey"]
                              # self.budget_D -= self.config["cost_D"]["Add_Honey"]
                              # self.total_cost_D += self.config["cost_D"]["Add_Honey"]
                         else:
                              vulnerabilities[v] *= self.config["skew_real"]

               vulnerability_lists[vulnerability_type] = vulnerabilities

          # print("\nVulnerabilities are: ")
          # for vulnerability_type, vulnerabilities in vulnerability_lists.items():
          #      print(f'{vulnerability_type} : {vulnerabilities}')

          return vulnerability_lists

     def set_success_rate(self, vulnerability_lists: Dict[str, Dict[str, float]]) -> None:
          """Generate combinations and assign random success probabilities."""
          # Create a list of valid vulnerabilities for each type
          valid_vulnerabilities_list = {}
          for vulnerability_type, vulnerabilities in vulnerability_lists.items():
               valid_vulnerabilities = [(v, p) for v, p in vulnerabilities.items() if p > self.config["likelihood_threshold"]]
               valid_vulnerabilities_list[vulnerability_type] = valid_vulnerabilities

          # print("\nValid vulnerabilities are: ")
          # for vulnerability_type, valid_vulnerabilities in valid_vulnerabilities_list.items():
          #      print(f'{vulnerability_type} : {valid_vulnerabilities}')

          # Extract valid vulnerabilities for each type
          valid_vulnerabilities_buffer = valid_vulnerabilities_list["Buffer"]
          valid_vulnerabilities_pointer = valid_vulnerabilities_list["Pointer"]
          valid_vulnerabilities_size = valid_vulnerabilities_list["Size"]

          # Generate unique combinations of 3 vulnerabilities, each from a different vulnerability type
          combinations = list(itertools.product(valid_vulnerabilities_buffer, valid_vulnerabilities_pointer, valid_vulnerabilities_size))

          for combination in combinations:
               # Calculate a success rate based on your logic
               # If redirect defense strategy is enabled, set a high success rate for combinations with honey vulnerabilities
               success_rate = random.uniform(0.1, 0.9)
               if self.defense_strategy == "PRIME_redirect" and any("honey" in vuln for vuln, _ in combination): # and self.budget_D > 0:
                    success_rate = random.uniform(0.8, 0.9)
                    # self.budget_D -= self.config["cost_D"]["Set_Honey_Success_Rate"]
                    # self.total_cost_D += self.config["cost_D"]["Set_Honey_Success_Rate"]

               # Store the success rate with the combination
               self.combination_success_rates[combination] = success_rate

          # print("\nCombinations and their success rates: ")
          # for combination, success_rate in self.combination_success_rates.items():
          #      print(f'{combination} : {success_rate}')
          print("\nNumber of combinations are: ", len(self.combination_success_rates))
     
     def pick_combination(self, vulnerability_lists: Dict[str, Dict[str, float]]) -> List[Tuple[str, float]]:
          """Randomly pick one vulnerability from each vulnerability list with bias."""
          combination = []

          for vulnerability_type, vulnerabilities in vulnerability_lists.items():
               # Extract vulnerabilities and probabilities into separate lists
               vulnerability_names, probabilities = zip(*vulnerabilities.items())

               # Use numpy choice to select a vulnerability based on probabilities
               selected_vulnerability = random.choices(vulnerability_names, probabilities, k=1)[0]

               # Assume it's an exploit and add it to the combination list
               combination.append((selected_vulnerability, vulnerabilities[selected_vulnerability]))

               # Deduct cost
               self.budget_A -= random.uniform(0, self.config["cost_A"][f"Find_{vulnerability_type}"])

               # if self.defense_strategy == "MTD" and self.budget_D > 0:
               #      self.budget_D -= self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities
               #      self.total_cost_D += self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities

               
               if self.defense_strategy == "PRIME_redirect" or self.defense_strategy == "PRIME_exhaust" and self.budget_D > 0:
                    self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_latency"])
                    self.total_cost_D += self.config["cost_D"]["PRIME_latency"]

          # print(f"\nAttacker selected combination {combination}")

          return combination

     def perform_exploit(self, combination: List[Tuple[str, float]]) -> float:
          """Get the exploit success rate for the selected combination."""
          success_rate = self.combination_success_rates.get(tuple(combination), 0)  # Default to 0 if combination not found
          
          self.budget_A -= self.config["cost_A"]["Perform_Exploit"]  # Assuming budget_A is global

          if self.defense_strategy == "MTD" and self.budget_D > 0:
               self.budget_D -= random.uniform(0, self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities) #* self.mtd_num_vulnerabilities
               self.total_cost_D += self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities #* self.mtd_num_vulnerabilities

          # if self.defense_strategy == "PRIME_redirect" or self.defense_strategy == "PRIME_exhaust" and self.budget_D > 0:
          #      self.budget_D -= self.config["cost_D"]["PRIME_latency"]
          #      self.total_cost_D += self.config["cost_D"]["PRIME_latency"]


          # print(f"\nSuccess rate for the {combination} selected is {success_rate}")
          return success_rate

     def replace_combination(self, combination: List[Tuple[str, float]]) -> List[Tuple[str, float]]:
          """Replace a real vulnerability with a honey one at some cost to Defender."""
          if self.defense_strategy == "PRIME_redirect" and self.budget_D > 0:
               combinations = [comb for comb in self.combination_success_rates.keys() if any("honey" in v for v, _ in comb)]   
               self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_latency"])
               self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_redirect"])  # Defender pays defense cost
               self.total_cost_D += self.config["cost_D"]["PRIME_redirect"]
               self.replace_budgets()


          if self.defense_strategy == "PRIME_exhaust" and self.budget_D > 0:
               combinations = [comb for comb in self.combination_success_rates.keys()] # if self.combination_success_rates.get(tuple(comb)) <= self.config["threshold"]]   
               self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_latency"])
               self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_exhaust"])  # Defender pays defense cost
               self.total_cost_D += self.config["cost_D"]["PRIME_exhaust"]

          if self.defense_strategy == "MTD" and self.budget_D > 0:
               combinations = [comb for comb in self.combination_success_rates.keys()] # if self.combination_success_rates.get(tuple(comb)) <= self.config["threshold"]]   
               # self.budget_D -= random.uniform(0, self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities) #* self.mtd_num_vulnerabilities
               # self.total_cost_D += self.config["cost_D"]["MTD"] * self.mtd_num_vulnerabilities #* self.mtd_num_vulnerabilities

          if not combinations:
               return ()  # No honey combinations found
          
          new_combination = random.choice(combinations)
          return new_combination
     
     def replace_budgets(self) -> None:
          """Transfer the remainder of attacker's budget to defender as information gain."""
          self.budget_D += self.budget_A
          self.budget_A = 0
          print(f"Defender gained information. Remaining budget for Defender is {self.budget_D}")

     def simulate_game(self, vulnerability_lists: Dict[str, Dict[str, float]]) -> None:
          """Simulate the game where Attacker attempts to exploit vulnerabilities and Defender defends."""
          num_tries = 0
          attacker_budgets = []
          defender_budgets = []
          while self.budget_A > 0:
               num_tries += 1
               combination = self.pick_combination(vulnerability_lists)
               success_rate = self.perform_exploit(combination)
               if self.defense_strategy == "PRIME_redirect" or self.defense_strategy == "PRIME_exhaust" and self.budget_D > 0:
                    self.budget_D -= random.uniform(0, self.config["cost_D"]["PRIME_latency"])

               attacker_budgets.append(self.budget_A)
               defender_budgets.append(self.budget_D)

               if success_rate >= self.config["threshold"]:
                    if self.defense_strategy == "PRIME_redirect" and any("honey" in vuln for vuln, _ in combination):
                         self.replace_budgets()    
                         print(f"Defender successfully protected against the honey combination")
                         print(f"Remaining defender budget is {self.budget_D} & attacker budget is {self.budget_A}. Number of tries {num_tries}")
                         break
                    if self.defense_strategy == "PRIME_exhaust" or self.defense_strategy == "MTD":
                         if self.budget_D > 0:
                              exhaust_combination = self.replace_combination(combination)
                              if exhaust_combination:
                                   print(f"Defender successfully protected against the correct combination by exhaust")
                                   print(f"Remaining defender budget is {self.budget_D} & attacker budget is {self.budget_A}. Number of tries {num_tries}")
                                   continue
                              else:
                                   print("There is no other combination, Attacker wins")
                                   break
                         else:
                              print(f"Defender exhausted the budget in {num_tries} tries")
                              break     
                    if self.defense_strategy == "PRIME_redirect":
                         if self.budget_D > 0:
                              honey_combination = self.replace_combination(combination)
                              if honey_combination:
                                   print(f"Defender successfully protected against the correct combination")
                                   print(f"Remaining defender budget is {self.budget_D} & attacker budget is {self.budget_A}. Number of tries {num_tries}")
                              else:
                                   print("There is no honey combination, Attacker wins")
                                   break
                         else:
                              print(f"Defender exhausted the budget in {num_tries} tries")
                              break         
                    if self.defense_strategy == "none":
                         print(f"Attacker successfully exploited a combination. Remaining budget is {self.budget_A}. Number of tries {num_tries}")
                         break
               else:
                    self.budget_A -= random.uniform(0, self.config["cost_A"]["Retry"])
                    print("Attacker failed to exploit the combination.")
                    print(f"Remaining defender budget is {self.budget_D} & attacker budget is {self.budget_A}. Number of tries {num_tries}")

          if self.budget_A <= 0:
               print("Attacker ran out of budget.")
               print(f"Defender has {self.budget_D} remaining after protecting against exploits. Number of tries {num_tries}")
               return attacker_budgets, defender_budgets
          if self.budget_D <= 0:
               print(f"Attacker wins with remaining budget of {self.budget_A}.")
               return attacker_budgets, defender_budgets

     def run_simulation(self) -> None:
          """Run the entire simulation."""
          vulnerability_lists = self.initialize_vulnerabilities()
          self.set_success_rate(vulnerability_lists)
          return self.simulate_game(vulnerability_lists)


if __name__ == "__main__":
     # Configuration Parameters
     simulation_config_simple = {
          "vulnerability_types": ["Buffer", "Pointer", "Size"],
          "threshold": 0.8,  # Exploit success threshold
          "num_vuln" : 100,
          "skew_real": 0.8,
          "skew_honey": 1.2,
          "likelihood_threshold": 0.4,
          "budget_A": 100,
          "budget_D": 100,
          "cost_A": {"Find_Buffer": 1, "Find_Pointer": 3, "Find_Size": 2, "Perform_Exploit": 1, "Retry": 1}, # , "Retry": 1
          "cost_D": {"MTD": 0.083, "PRIME_redirect": 3, "PRIME_exhaust": 2, "PRIME_latency": 2}, # , "Set_Honey_Success_Rate": 2 "Add_Honey": 10, 
          "defense_strategy": "PRIME_exhaust",  # Options: "PRIME_redirect", "PRIME_exhaust", "MTD", "none"
          "honey_viable_types": ["Pointer"],  # Vulnerability types that can be defended by redirect
          "honey_fraction": 0.05,  # Fraction of vulnerabilities that can be honey for redirect defense
     }
     # simulation_config_r2libc = {
     #      "vulnerability_types": ["Buffer", "Pointer_Return"],
     #      "attack_variables": ["Payload_Size", "Target_Addr"],
     #      "threshold": 0.8,  # Exploit success threshold
     #      "num_vuln" : 100,
     #      "skew_real": 0.8,
     #      "skew_honey": 1.2,
     #      "likelihood_threshold": 0.4,
     #      "budget_A": 100,
     #      "budget_D": 100,
     #      "cost_A": {"Find_Buffer": 1, "Find_Pointer": 3, "Find_Size": 2, "Perform_Exploit": 1, "Retry": 1},
     #      "cost_D": {"MTD": 0.083, "PRIME_redirect": 3, "PRIME_exhaust": 2, "PRIME_latency": 0.1}, # , "Set_Honey_Success_Rate": 2 "Add_Honey": 10, 
     #      "defense_strategy": "PRIME_redirect",  # Options: "PRIME_redirect", "PRIME_exhaust", "MTD", "none"
     #      "honey_viable_types": ["Pointer"],  # Vulnerability types that can be defended by redirect
     #      "honey_fraction": 0.05,  # Fraction of vulnerabilities that can be honey for redirect defense
     # }
     # simulation_config_rop = {
     #      "vulnerability_types": ["Buffer", "Pointer", "Code_Gadgets"],
     #      "attack_variables": ["Payload_Size", "Target_Addr"],
     #      "threshold": 0.8,  # Exploit success threshold
     #      "num_vuln" : 100,
     #      "skew_real": 0.8,
     #      "skew_honey": 1.2,
     #      "likelihood_threshold": 0.4,
     #      "budget_A": 100,
     #      "budget_D": 100,
     #      "cost_A": {"Find_Buffer": 1, "Find_Pointer": 3, "Find_Size": 2, "Perform_Exploit": 1, "Retry": 1},
     #      "cost_D": {"MTD": 0.83, "PRIME_redirect": 3.5, "PRIME_exhaust": 2, "PRIME_latency": 0.1}, # , "Set_Honey_Success_Rate": 2 "Add_Honey": 10, 
     #      "defense_strategy": "PRIME_redirect",  # Options: "PRIME_redirect", "PRIME_exhaust", "MTD", "none"
     #      "honey_viable_types": ["Pointer"],  # Vulnerability types that can be defended by redirect
     #      "honey_fraction": 0.05,  # Fraction of vulnerabilities that can be honey for redirect defense
     # }

     # Create a GameSimulation instance and run the simulation
     game_simulation = GameSimulation(simulation_config_simple)
     attacker_budgets, defender_budgets = game_simulation.run_simulation()

     # Plotting
     plt.plot(range(len(attacker_budgets)), attacker_budgets, label='Attacker Budget')
     plt.plot(range(len(defender_budgets)), defender_budgets, label='Defender Budget')
     plt.xlabel('Number of Tries')
     plt.ylabel('Budget')
     plt.title('Attacker and Defender Budgets Over Tries')
     plt.legend()
     plt.show()


# Back calculations from Morpheus:
# takes 10ms for 300k pointers
# 33.33ns for 1 pointer
# 2.5GHz processor so 1 cycle takes 0.4ns
# therefore 1 pointer churn takes 83.33 cycles
# if MTD cost is 1 per 100 cycles then count the displacement cost per attacker action based on number of vulnerable pointers in the code.
# ex: for each attacker action, if there are 15 pointers then defender's cost would be 15*0.83 = 12.45

# Back calculations for PRIME:
# 350 cycles for one pointer replacement subroutine
# cost for defender = 3.5

# Back calculations for attacker and defender:
# give them 2 seconds to perform actions
# convert to cycles for 2.5GHz processor is 5*10^9 cycles, i.e., 5*10^7 points as budget

# Back calculations for attacker actions:
# each action to find buffer can take 
